<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>贪吃蛇大战 — 单文件</title>
  <style>
    :root{--bg:#0f1720;--grid:#0b1220;--panel:#0b1220;--text:#e6eef8;--accent1:#22c55e;--accent2:#60a5fa}
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans",Helvetica,Arial,'PingFang SC','Hiragino Sans GB',"Microsoft YaHei"}
    body{display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#071126 0%,#0b1220 100%);color:var(--text)}
    .wrap{width:920px;max-width:96%;display:grid;grid-template-columns:1fr 320px;gap:18px;padding:22px}
    .board-card{background:linear-gradient(180deg,#081620,#04101a);border-radius:12px;padding:14px;box-shadow:0 6px 20px rgba(2,6,23,.6)}
    canvas{background:linear-gradient(180deg,#071826,#04242b);display:block;border-radius:8px}

    .panel{background:linear-gradient(180deg,#061021,#071426);border-radius:12px;padding:16px;color:var(--text);display:flex;flex-direction:column;gap:12px}
    h1{margin:0;font-size:18px}
    .info{font-size:13px;line-height:1.6}
    .controls{display:flex;flex-direction:column;gap:8px}
    .row{display:flex;gap:8px;align-items:center}
    .btn{background:transparent;border:1px solid rgba(255,255,255,.06);padding:8px 10px;border-radius:8px;color:var(--text);cursor:pointer}
    .btn.primary{background:linear-gradient(90deg,var(--accent1),#16a34a);border:none}
    .score{display:flex;gap:8px;align-items:center}
    .badge{padding:6px 10px;border-radius:10px;background:rgba(255,255,255,0.04)}
    footer{font-size:12px;color:rgba(255,255,255,0.6)}
    .legend{display:flex;gap:8px;align-items:center}
    .chip{width:14px;height:14px;border-radius:4px}
    .muted{color:rgba(255,255,255,0.6);font-size:13px}
    .hint{font-size:12px;color:rgba(255,255,255,0.6)}

    @media (max-width:760px){.wrap{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="board-card">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
        <h1>贪吃蛇大战 — 本地双人对战</h1>
        <div class="muted">分数随长度增长 · 撞墙/撞身亡</div>
      </div>
      <canvas id="game" width="560" height="560"></canvas>
    </div>

    <aside class="panel">
      <div>
        <div class="row" style="justify-content:space-between;align-items:flex-start">
          <div>
            <div class="score"><strong>玩家 1</strong><div class="badge" id="score1">0</div></div>
            <div class="muted">方向键控制 (↑↓←→)</div>
          </div>
          <div>
            <div class="score"><strong>玩家 2</strong><div class="badge" id="score2">0</div></div>
            <div class="muted">W A S D 控制</div>
          </div>
        </div>
      </div>

      <div class="controls">
        <div class="row"><button class="btn primary" id="startBtn">开始 / 重新开始</button><button class="btn" id="pauseBtn">暂停</button></div>
        <div class="row"><label class="hint">速度 (格/秒)</label><input id="speed" type="range" min="4" max="18" value="8" style="flex:1"></div>
        <div class="row"><label class="hint">网格大小 (像素)</label><input id="cellSize" type="range" min="10" max="30" value="20" style="flex:1"></div>
      </div>

      <div>
        <div class="legend"><div class="chip" style="background:var(--accent1)"></div><div>玩家1 (绿)</div></div>
        <div class="legend"><div class="chip" style="background:var(--accent2)"></div><div>玩家2 (蓝)</div></div>
        <div class="legend" style="margin-top:8px"><div class="chip" style="background:#ef4444"></div><div>食物 (红)</div></div>
      </div>

      <div style="margin-top:8px" class="muted">
        按键说明：<br>
        玩家1: 箭头键 (上/下/左/右) ； 玩家2: W A S D<br>
        规则：吃到食物增长并得分；撞墙或撞到任意蛇身均会死亡；头撞头视为平局
      </div>

      <footer style="margin-top:auto">如果需要联机/AI或多食物模式，告诉我我来加功能。</footer>
    </aside>
  </div>

  <script>
  // 贪吃蛇大战 — 单文件实现
  (function(){
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // UI
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const speedInput = document.getElementById('speed');
    const cellInput = document.getElementById('cellSize');
    const score1El = document.getElementById('score1');
    const score2El = document.getElementById('score2');

    // 状态
    let width = canvas.width;
    let height = canvas.height;
    let CELL = parseInt(cellInput.value,10);
    let COLS = Math.floor(width / CELL);
    let ROWS = Math.floor(height / CELL);
    let fps = parseInt(speedInput.value,10);

    let timerId = null;
    let running = false;

    // 蛇模板
    function createSnake(x,y,dir,color){
      return {
        body: [{x,y}],
        dir: dir, // {x:0,y:-1} etc
        nextDir: dir,
        alive: true,
        color
      }
    }

    const SNAKE1_INIT = {x: Math.floor(COLS*0.25), y: Math.floor(ROWS/2)};
    const SNAKE2_INIT = {x: Math.floor(COLS*0.75), y: Math.floor(ROWS/2)};

    let snake1 = createSnake(SNAKE1_INIT.x,SNAKE1_INIT.y, {x:1,y:0}, '#22c55e');
    let snake2 = createSnake(SNAKE2_INIT.x,SNAKE2_INIT.y, {x:-1,y:0}, '#60a5fa');

    let food = null;

    function randCell(){
      return {x: Math.floor(Math.random()*COLS), y: Math.floor(Math.random()*ROWS)};
    }

    function placeFood(){
      // 找一个不在任何蛇身上的格子
      let tries = 0;
      while(tries++ < 10000){
        const c = randCell();
        if(!cellOccupied(c.x,c.y)){
          food = c; return;
        }
      }
      // 极端情况：无处放置
      food = null;
    }

    function cellOccupied(x,y){
      for(const s of [snake1,snake2]){
        for(const b of s.body){ if(b.x===x && b.y===y) return true }
      }
      return false;
    }

    function reset(){
      CELL = parseInt(cellInput.value,10);
      COLS = Math.floor(width / CELL);
      ROWS = Math.floor(height / CELL);
      fps = parseInt(speedInput.value,10);

      snake1 = createSnake(Math.floor(COLS*0.25), Math.floor(ROWS/2), {x:1,y:0}, '#22c55e');
      // 给蛇1再推延伸2段以便游戏开始
      snake1.body.push({x:snake1.body[0].x-1,y:snake1.body[0].y});
      snake1.body.push({x:snake1.body[0].x-2,y:snake1.body[0].y});

      snake2 = createSnake(Math.floor(COLS*0.75), Math.floor(ROWS/2), {x:-1,y:0}, '#60a5fa');
      snake2.body.push({x:snake2.body[0].x+1,y:snake2.body[0].y});
      snake2.body.push({x:snake2.body[0].x+2,y:snake2.body[0].y});

      placeFood();
      updateScores();
      draw();
    }

    function updateScores(){
      score1El.textContent = String(Math.max(0, snake1.body.length - 3));
      score2El.textContent = String(Math.max(0, snake2.body.length - 3));
    }

    function step(){
      if(!snake1.alive && !snake2.alive){ running=false; clearInterval(timerId); return }

      // apply queued directions (防止反向)
      [snake1,snake2].forEach(s=>{
        const nd = s.nextDir;
        if(nd.x !== -s.dir.x || nd.y !== -s.dir.y) s.dir = nd;
      });

      // compute next head positions
      const next1 = {x: snake1.body[0].x + snake1.dir.x, y: snake1.body[0].y + snake1.dir.y};
      const next2 = {x: snake2.body[0].x + snake2.dir.x, y: snake2.body[0].y + snake2.dir.y};

      // collision detection helper
      function outOfBounds(p){ return p.x<0 || p.x>=COLS || p.y<0 || p.y>=ROWS }
      function hitBody(p, snake){
        for(let i=0;i<snake.body.length;i++){ if(snake.body[i].x===p.x && snake.body[i].y===p.y) return true }
        return false;
      }

      // head-to-head
      if(next1.x===next2.x && next1.y===next2.y){
        // 平局：两者都死
        snake1.alive = false; snake2.alive = false;
        running=false; clearInterval(timerId);
        showResult('平局！头部相撞');
        draw(); return;
      }

      // check individual collisions
      // snake1
      if(snake1.alive){
        if(outOfBounds(next1) || hitBody(next1,snake1) || hitBody(next1,snake2)){
          snake1.alive = false;
        }
      }
      if(snake2.alive){
        if(outOfBounds(next2) || hitBody(next2,snake2) || hitBody(next2,snake1)){
          snake2.alive = false;
        }
      }

      // move snakes (only if alive)
      if(snake1.alive){
        snake1.body.unshift(next1);
        // eat food?
        if(food && next1.x===food.x && next1.y===food.y){ placeFood(); }
        else snake1.body.pop();
      }

      if(snake2.alive){
        snake2.body.unshift(next2);
        if(food && next2.x===food.x && next2.y===food.y){ placeFood(); }
        else snake2.body.pop();
      }

      // check if someone wins (one alive)
      if(!snake1.alive && snake2.alive){ running=false; clearInterval(timerId); showResult('玩家 2 胜利！'); }
      else if(!snake2.alive && snake1.alive){ running=false; clearInterval(timerId); showResult('玩家 1 胜利！'); }

      updateScores();
      draw();
    }

    function showResult(text){
      // 简单提示
      setTimeout(()=>{ alert(text) }, 120);
    }

    function drawGrid(){
      ctx.save();
      // grid background
      ctx.fillStyle = '#02161a';
      ctx.fillRect(0,0,width,height);
      // subtle grid lines
      ctx.strokeStyle = 'rgba(255,255,255,0.02)';
      ctx.lineWidth = 1;
      for(let x=0;x<=COLS;x++){
        ctx.beginPath(); ctx.moveTo(x*CELL,0); ctx.lineTo(x*CELL,height); ctx.stroke();
      }
      for(let y=0;y<=ROWS;y++){
        ctx.beginPath(); ctx.moveTo(0,y*CELL); ctx.lineTo(width,y*CELL); ctx.stroke();
      }
      ctx.restore();
    }

    function draw(){
      ctx.clearRect(0,0,width,height);
      drawGrid();

      // draw food
      if(food){
        drawCell(food.x,food.y,'#ef4444');
        // small shine
        ctx.fillStyle = 'rgba(255,255,255,0.12)';
        ctx.fillRect(food.x*CELL+CELL*0.22, food.y*CELL+CELL*0.22, CELL*0.26, CELL*0.26);
      }

      // draw snakes
      [snake1,snake2].forEach(s=>{
        // body
        for(let i=s.body.length-1;i>=0;i--){
          const b = s.body[i];
          const t = i===0 ? 0.95 : 0.75 - i*0.01; // head brighter
          drawCell(b.x,b.y, shade(s.color,t));
        }
        // outline head
        if(s.body.length){
          const h = s.body[0];
          ctx.strokeStyle = 'rgba(0,0,0,0.45)';
          ctx.lineWidth = 2; ctx.strokeRect(h.x*CELL+1, h.y*CELL+1, CELL-2, CELL-2);
        }
      });
    }

    function drawCell(cx,cy,color){
      ctx.fillStyle = color;
      ctx.fillRect(cx*CELL+1, cy*CELL+1, CELL-2, CELL-2);
    }

    // 简单颜色 shade
    function shade(hex, t){
      // hex like #rrggbb
      if(!/^#([0-9a-fA-F]{6})$/.test(hex)) return hex;
      const r = parseInt(hex.slice(1,3),16);
      const g = parseInt(hex.slice(3,5),16);
      const b = parseInt(hex.slice(5,7),16);
      const nr = Math.min(255, Math.round(r * t));
      const ng = Math.min(255, Math.round(g * t));
      const nb = Math.min(255, Math.round(b * t));
      return `rgb(${nr},${ng},${nb})`;
    }

    // keyboard controls
    window.addEventListener('keydown', (e)=>{
      // prevent arrow scrolling
      if([37,38,39,40].includes(e.keyCode)) e.preventDefault();
      switch(e.code){
        // player2 = WASD
        case 'KeyW': snake2.nextDir = {x:0,y:-1}; break;
        case 'KeyS': snake2.nextDir = {x:0,y:1}; break;
        case 'KeyA': snake2.nextDir = {x:-1,y:0}; break;
        case 'KeyD': snake2.nextDir = {x:1,y:0}; break;
        // player1 = arrows
        case 'ArrowUp': snake1.nextDir = {x:0,y:-1}; break;
        case 'ArrowDown': snake1.nextDir = {x:0,y:1}; break;
        case 'ArrowLeft': snake1.nextDir = {x:-1,y:0}; break;
        case 'ArrowRight': snake1.nextDir = {x:1,y:0}; break;
        case 'Space': // 暂停/继续
          togglePause(); break;
      }
    });

    function togglePause(){
      if(!running){ startGame(); }
      else{ running=false; clearInterval(timerId); }
    }

    // start / stop
    function startGame(){
      if(running) { // already running -> restart
        clearInterval(timerId);
      }
      // ensure both alive
      snake1.alive = true; snake2.alive = true;
      running = true;
      fps = parseInt(speedInput.value,10);
      // set interval
      const ms = Math.round(1000 / fps);
      timerId = setInterval(step, ms);
      draw();
    }

    startBtn.addEventListener('click', ()=>{ reset(); startGame(); });
    pauseBtn.addEventListener('click', ()=>{ togglePause(); });
    speedInput.addEventListener('input', ()=>{
      fps = parseInt(speedInput.value,10);
      if(running){ clearInterval(timerId); timerId = setInterval(step, Math.round(1000/fps)); }
    });
    cellInput.addEventListener('input', ()=>{
      // 更新格子大小需要重置
      reset();
    });

    // 优化画布在高DPI屏幕上清晰
    function resizeCanvas(){
      const ratio = window.devicePixelRatio || 1;
      const w = 560; const h = 560;
      canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
      canvas.width = Math.floor(w * ratio); canvas.height = Math.floor(h * ratio);
      ctx.scale(ratio, ratio);
      width = w; height = h;
    }

    // 初始化
    resizeCanvas(); reset(); draw();

    // 窗口重新调整时重新绘制（但暂不改变实际尺寸）
    window.addEventListener('resize', ()=>{ draw(); });
  })();
  </script>
</body>
</html>
